////

struct Vec2 { 
    double x;
    double y;
};

struct Mat3 {
    // row-major 3x3
    double m[9]{};
    double& operator()(int r, int c) 
    { 
        return m[r * 3 + c]; 
    }
    double  operator()(int r, int c) const 
    { 
        return m[r * 3 + c]; 
    }
};

static double det3(const Mat3& A) {
    double ret;
    ret = A(0, 0) * (A(1, 1) * A(2, 2) - A(1, 2) * A(2, 1)) -
          A(0, 1) * (A(1, 0) * A(2, 2) - A(1, 2) * A(2, 0)) +
          A(0, 2) * (A(1, 0) * A(2, 1) - A(1, 1) * A(2, 0));

    return ret;
}

static Mat3 inv3(const Mat3& A) {
    double d = det3(A);

    if (std::abs(d) < 1e-15) {
        std::cerr << "Matrix not invertible (det ~ 0)\n";
        Mat3 I{}; I(0, 0) = I(1, 1) = I(2, 2) = 1.0;
        return I;
    }

    Mat3 B{};
    // adjugate / det
    B(0, 0) = (A(1, 1) * A(2, 2) - A(1, 2) * A(2, 1)) / d;
    B(0, 1) = -(A(0, 1) * A(2, 2) - A(0, 2) * A(2, 1)) / d;
    B(0, 2) = (A(0, 1) * A(1, 2) - A(0, 2) * A(1, 1)) / d;

    B(1, 0) = -(A(1, 0) * A(2, 2) - A(1, 2) * A(2, 0)) / d;
    B(1, 1) = (A(0, 0) * A(2, 2) - A(0, 2) * A(2, 0)) / d;
    B(1, 2) = -(A(0, 0) * A(1, 2) - A(0, 2) * A(1, 0)) / d;

    B(2, 0) = (A(1, 0) * A(2, 1) - A(1, 1) * A(2, 0)) / d;
    B(2, 1) = -(A(0, 0) * A(2, 1) - A(0, 1) * A(2, 0)) / d;
    B(2, 2) = (A(0, 0) * A(1, 1) - A(0, 1) * A(1, 0)) / d;
    return B;
}

static Vec2 apply_homography(const Mat3& H, double x, double y) {
    double X = H(0, 0) * x + H(0, 1) * y + H(0, 2);
    double Y = H(1, 0) * x + H(1, 1) * y + H(1, 2);
    double W = H(2, 0) * x + H(2, 1) * y + H(2, 2);
    if (std::abs(W) < 1e-12) return { 0,0 };
    return { X / W, Y / W };
}

// ---------- 8x8 連立一次方程式をガウス消去で解く（部分ピボット付き） ----------
static bool solve8x8(double A[8][8], double b[8], double x[8]) {
    double M[8][9];
    for (int r = 0; r < 8; r++) {
        for (int c = 0; c < 8; c++) M[r][c] = A[r][c];
        M[r][8] = b[r];
    }

    for (int col = 0; col < 8; col++) {
        // pivot
        int pivot = col;
        double best = std::abs(M[col][col]);
        for (int r = col + 1; r < 8; r++) {
            double v = std::abs(M[r][col]);
            if (v > best) { best = v; pivot = r; }
        }
        if (best < 1e-12) return false;

        if (pivot != col) {
            for (int c = col; c < 9; c++) std::swap(M[col][c], M[pivot][c]);
        }

        // normalize
        double div = M[col][col];
        for (int c = col; c < 9; c++) M[col][c] /= div;

        // eliminate
        for (int r = 0; r < 8; r++) {
            if (r == col) continue;
            double f = M[r][col];
            if (std::abs(f) < 1e-15) continue;
            for (int c = col; c < 9; c++) {
                M[r][c] -= f * M[col][c];
            }
        }
    }

    for (int i = 0; i < 8; i++) x[i] = M[i][8];
    return true;
}

// ---------- 4点対応からホモグラフィ推定（h33=1固定のDLT） ----------
static bool homography_from_4pts(const Vec2 src[4], const Vec2 dst[4], Mat3& H) {
    // Unknowns: h11 h12 h13 h21 h22 h23 h31 h32 (h33=1)
    double A[8][8]{};
    double b[8]{};

    for (int i = 0; i < 4; i++) {
        double x = src[i].x, y = src[i].y;
        double u = dst[i].x, v = dst[i].y;

        int r0 = 2 * i;
        int r1 = 2 * i + 1;

        // u equation
        A[r0][0] = x;  A[r0][1] = y;  A[r0][2] = 1;
        A[r0][3] = 0;  A[r0][4] = 0;  A[r0][5] = 0;
        A[r0][6] = -u * x; A[r0][7] = -u * y;
        b[r0] = u;

        // v equation
        A[r1][0] = 0;  A[r1][1] = 0;  A[r1][2] = 0;
        A[r1][3] = x;  A[r1][4] = y;  A[r1][5] = 1;
        A[r1][6] = -v * x; A[r1][7] = -v * y;
        b[r1] = v;
    }

    double h[8]{};
    if (!solve8x8(A, b, h)) return false;

    H = Mat3{};
    H(0, 0) = h[0]; H(0, 1) = h[1]; H(0, 2) = h[2];
    H(1, 0) = h[3]; H(1, 1) = h[4]; H(1, 2) = h[5];
    H(2, 0) = h[6]; H(2, 1) = h[7]; H(2, 2) = 1.0;
    return true;
}

static inline uchar sat_u8(int v) {
    return (uchar)std::max(0, std::min(255, v));
}

static bool sample_bilinear(const cv::Mat& src,double x, double y, uchar& out) {
    if (x < 0 || y < 0 || x >= src.cols - 1 || y >= src.rows - 1)
        return false;

    int x0 = (int)std::floor(x);
    int y0 = (int)std::floor(y);
    int x1 = x0 + 1;
    int y1 = y0 + 1;

    double tx = x - x0;
    double ty = y - y0;

    uchar p00 = src.at<uchar>(y0, x0);
    uchar p10 = src.at<uchar>(y0, x1);
    uchar p01 = src.at<uchar>(y1, x0);
    uchar p11 = src.at<uchar>(y1, x1);

    double a = p00 * (1.0 - tx) + p10 * tx;
    double b = p01 * (1.0 - tx) + p11 * tx;
    double v = a * (1.0 - ty) + b * ty;

    int iv = (int)std::lround(v);
    if (iv < 0) iv = 0;
    if (iv > 255) iv = 255;
    out = (uchar)iv;
    return true;
}

static cv::Mat warp_perspective(const cv::Mat& src,const Mat3& H,int outW, int outH,uchar border = 0) 
{
    cv::Mat dst(outH, outW, CV_8UC1, border);
    Mat3 Hinv = inv3(H);

    for (int v = 0; v < outH; v++) {
        for (int u = 0; u < outW; u++) {
            Vec2 p = apply_homography(Hinv, (double)u, (double)v);
            uchar col;
            if (sample_bilinear(src, p.x, p.y, col)) {
                dst.at<uchar>(v, u) = col;
            }
        }
    }
    return dst;
}

cv::Mat PerspectiveTransform(cv::Mat src) {

    if (src.empty()) {
        std::cerr << "failed to load input file\n";
    }
    // ---- ここをあなたの画像に合わせて指定（TL,TR,BR,BL）----
    Vec2 srcPts[4] = {
        {150, 300}, // TL
        {450, 150}, // TR
        {580, 260}, // BR
        {230, 460}  // BL
    };

    // 出力の4点（例：矩形に正規化）
    int outW = 500, outH = 250;
    Vec2 dstPts[4] = {
        {0, 0},
        {outW - 1.0, 0},
        {outW - 1.0, outH - 1.0},
        {0, outH - 1.0}
    };

    Mat3 H{};
    if (!homography_from_4pts(srcPts, dstPts, H)) {
        std::cerr << "failed to compute homography\n";
    }

    cv::Mat dst = warp_perspective(src, H, outW, outH, 0);
//    cv::imwrite("warped.png", dst);

    return dst;

}
